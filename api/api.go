package api

import (
	"database/sql"
	"errors"
	"net/http"
	"os"
	"strconv"
	"time"

	"github.com/Iknite-Space/sqlc-example-api/db/repo"
	"github.com/Iknite-Space/sqlc-example-api/db/store"
	"github.com/Iknite-Space/sqlc-example-api/helper"
	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgtype"
)

// messageHandler holds the methods that respond to http routes
// it stores the repo.querier, which is the interface generated by sqlc
type MessageHandler struct {
	querier store.Store
}

func NewMessageHandler(querier store.Store) *MessageHandler {
	return &MessageHandler{
		querier: querier,
	} //constructor that allows you to inject your querier (either a Queries instance or a transaction-based one)
}

// HTTP router setup
// wires up all the route and returns an http handler you can plug into your server
func (h *MessageHandler) WireHttpHandler() http.Handler {

	r := gin.Default()
	r.Use(gin.CustomRecovery(func(c *gin.Context, _ any) {
		c.String(http.StatusInternalServerError, "Internal Server Error: panic")
		c.AbortWithStatus(http.StatusInternalServerError)
	})) //prevents the server from crashing if an error occurs in any route

	r.POST("/thread", h.handleCreateThread)
	r.POST("/message", h.handleCreateMessage)
	r.GET("/message/:id", h.handleGetMessage)
	// r.GET("/thread/:threadId/messages", h.handleGetThreadMessages)
	r.DELETE("/message/:id", h.handleDeleteMessageById)
	r.DELETE("/thread/:threadId/messages", h.handleDeleteMessageByThreadId)
	r.PATCH("/message", h.handleUpdateMessage)
	// r.POST("/order", h.handleCreateOrder)
	r.GET("/thread/:threadId/messages", h.handleGetPaginatedThreadMessages)

	r.POST("/category", h.handleCreateCategory)
	r.POST("/product", h.handleCreateProduct)
	r.POST("/order", h.handleCreateOrder)
	r.GET("/payment/webhook", h.handlePaymentWebhook)

	return r
}

func (h *MessageHandler) handleCreateCategory(c *gin.Context) {
	var req repo.CreateProductCategoryParams
	if err := c.ShouldBindBodyWithJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	category, err := h.querier.Do().CreateProductCategory(c, req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, category)
}

// CreateProductRequest is for receiving from frontend
type CreateProductRequest struct {
	CategoryID     int32                               `json:"category_id"`
	Name           string                              `json:"name"`
	Slug           string                              `json:"slug"`
	Description    string                              `json:"description"`
	Type           string                              `json:"type"` // single or variable
	RegularPrice   pgtype.Numeric                      `json:"regular_price"`
	SalePrice      pgtype.Numeric                      `json:"sale_price"`
	SKU            *string                             `json:"sku"`
	MainImageUrl   *string                             `json:"main_image_url"`
	Variations     []repo.CreateProductVariationParams `json:"variations,omitempty"`
	Stock          repo.CreateStockParams              `json:"stock,omitempty"`           // for single products
	VariationStock []repo.CreateStockParams            `json:"variation_stock,omitempty"` // for variable products
	Gallery        []repo.CreateProductGalleryParams   `json:"gallery,omitempty"`
}

func (h *MessageHandler) handleCreateProduct(c *gin.Context) {
	var req CreateProductRequest

	if err := c.ShouldBindBodyWithJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload", "details": err.Error()})
		return
	}

	// Start the transaction
	q, tx, err := h.querier.Begin(c)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to begin transaction"})
		return
	}
	defer tx.Rollback(c) // Will rollback unless committed later

	var pid, stockId int32

	// Create stock if provided, for single products
	if req.Type == "single" && req.Stock != (repo.CreateStockParams{}) {
		stockID, err := q.CreateStock(c, req.Stock)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create stock", "details": err.Error()})
			return
		}
		stockId = stockID
	}

	// Create product based on type
	switch req.Type {
	case "single":
		pid, err = q.CreateSingleProduct(c, repo.CreateSingleProductParams{
			CategoryID:   &req.CategoryID,
			Name:         req.Name,
			Slug:         req.Slug,
			Description:  req.Description,
			RegularPrice: req.RegularPrice,
			SalePrice:    req.SalePrice,
			Sku:          req.SKU,
			StockID:      &stockId,
			MainImageUrl: req.MainImageUrl,
		})
	case "variable":
		pid, err = q.CreateVariableProduct(c, repo.CreateVariableProductParams{
			CategoryID:   &req.CategoryID,
			Name:         req.Name,
			Slug:         req.Slug,
			Description:  req.Description,
			MainImageUrl: req.MainImageUrl,
		})
	default:
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product type"})
		return
	}

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create product", "details": err.Error()})
		return
	}

	// Handle variations (for variable products)
	if req.Type == "variable" && len(req.Variations) > 0 {
		for i, variation := range req.Variations {
			var stockID *int32 = nil //default to nil for missing stock

			// if there's a corresponding stock for this variation, create it
			if i < len(req.VariationStock) {
				stock := req.VariationStock[i]
				newStockID, err := q.CreateStock(c, repo.CreateStockParams{
					Quantity:          stock.Quantity,
					LowStockThreshold: stock.LowStockThreshold,
				})
				if err != nil {
					c.JSON(http.StatusInternalServerError, gin.H{
						"error":   "failed to create stock for variation",
						"details": err.Error(),
					})
					return
				}
				stockID = &newStockID // assign stock ID
			}

			//create the product variation
			variation.ProductID = &pid
			_, err := q.CreateProductVariation(c, repo.CreateProductVariationParams{
				ProductID:      variation.ProductID,
				VariationName:  variation.VariationName,
				VariationValue: variation.VariationValue,
				RegularPrice:   variation.RegularPrice,
				SalePrice:      variation.SalePrice,
				Sku:            variation.Sku,
				StockID:        stockID,
			})
			if err != nil {
				c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create variation", "details": err.Error()})
				return
			}
		}
	}

	// Handle gallery images
	if len(req.Gallery) > 0 {
		for _, gallery := range req.Gallery {
			gallery.ProductID = &pid
			err := q.CreateProductGallery(c, repo.CreateProductGalleryParams{
				ProductID: gallery.ProductID,
				ImageUrl:  gallery.ImageUrl,
			})
			if err != nil {
				c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create gallery", "details": err.Error()})
				return
			}
		}
	}

	// Commit the transaction
	if err := tx.Commit(c); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to commit transaction", "details": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "product created successfully", "product_id": pid})
}

type CreateOrderRequest struct {
	CustomerID      *int32                        `json:"customer_id"`
	TotalAmount     pgtype.Numeric                `json:"total_amount"`
	ShippingAddress string                        `json:"shipping_address"`
	BillingAddress  string                        `json:"billing_address"`
	Items           []repo.CreateOrderItemsParams `json:"items,omitempty"`
	Payment         repo.CreatePaymentParams      `json:"payment"`
}

func (h *MessageHandler) handleCreateOrder(c *gin.Context) {
	var req CreateOrderRequest
	if err := c.ShouldBindBodyWithJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload", "details": err.Error()})
		return
	}
	// Start the transaction
	q, tx, err := h.querier.Begin(c)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to begin transaction"})
		return
	}
	defer tx.Rollback(c) // Will rollback unless committed later

	var orderId int32
	// Create the order
	orderId, err = q.CreateOrder(c, repo.CreateOrderParams{
		CustomerID:      req.CustomerID,
		TotalAmount:     req.TotalAmount,
		ShippingAddress: req.ShippingAddress,
		BillingAddress:  req.BillingAddress,
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create order", "details": err.Error()})
		return
	}

	//add the order items
	for _, item := range req.Items {
		item.OrderID = &orderId
		if _, err := q.CreateOrderItems(c, repo.CreateOrderItemsParams{
			OrderID:   item.OrderID,
			ProductID: item.ProductID,
			Quantity:  item.Quantity,
			Price:     item.Price,
		}); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create order items", "details": err.Error()})
			return
		}
	}

	//initiate the payment via campay
	token := os.Getenv("AUTH_TOKEN")
	amountStr, err := helper.NumericToString(req.Payment.Amount)
	if err != nil {
		return
	}
	reference, err := requestPayment(req.BillingAddress, amountStr, "Order Payment", token)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to initiate payment", "details": err.Error()})
		return
	}

	// Create the payment
	err = q.CreatePayment(c, repo.CreatePaymentParams{
		OrderID:              &orderId,
		Amount:               req.Payment.Amount,
		PaymentMethod:        req.Payment.PaymentMethod,
		TransactionReference: &reference,
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create payment", "details": err.Error()})
		return
	}

	//wait for the payment to be completed
	timeCount := 4
	var paymentStatus string
	for i := 0; i < timeCount; i++ {
		time.Sleep(5 * time.Second)
		paymentStatus = CheckTransationStatus(token, reference)
		if paymentStatus != "PENDING" {
			//update the payment status
			if _, err := q.UpdatePaymentStatus(c, repo.UpdatePaymentStatusParams{
				TransactionReference: &reference,
				PaymentStatus:        &paymentStatus,
			}); err != nil {
				c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update payment status", "details": err.Error()})
				return
			}
			break
		}
	}

	// Commit the transaction
	if err := tx.Commit(c); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to commit transaction", "details": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{
		"message":        "order created successfully",
		"order_id":       orderId,
		"payment_status": paymentStatus,
	})

}

// campay payment webhook
func (h *MessageHandler) handlePaymentWebhook(c *gin.Context) {
	status := c.Query("status")
	reference := c.Query("reference")
	if status == "" || reference == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "status and reference are required"})
		return
	}
	// Update the payment status in the database
	if _, err := h.querier.Do().UpdatePaymentStatus(c, repo.UpdatePaymentStatusParams{
		TransactionReference: &reference,
		PaymentStatus:        &status,
	}); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update payment status"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "payment status updated successfully"})
}

type CreateThreadParams struct {
	Title string `json:"title"`
}

func (h *MessageHandler) handleCreateThread(c *gin.Context) {
	var req CreateThreadParams
	if err := c.ShouldBindBodyWithJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	thread, err := h.querier.Do().CreateThread(c, req.Title)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, thread)
}

func (h *MessageHandler) handleCreateMessage(c *gin.Context) {
	var req repo.CreateMessageParams
	if err := c.ShouldBindBodyWithJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// first check whether the thread exist
	_, err := h.querier.Do().GetThreadById(c, req.ThreadID)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Thread not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Server error"})
		return
	}

	//now we proceed to create the message
	message, err := h.querier.Do().CreateMessage(c, req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, message)
}

func (h *MessageHandler) handleGetMessage(c *gin.Context) {
	id := c.Param("id")
	if id == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "id is required"})
		return
	}

	message, err := h.querier.Do().GetMessageByID(c, id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, message)
}

// func (h *MessageHandler) handleGetThreadMessages(c *gin.Context) {
// 	id := c.Param("threadId")
// 	intVal, err := helper.GetParamAsInt32(id)

// 	if err != nil {
// 		c.JSON(http.StatusBadRequest, err.Error())
// 		return
// 	}

// 	messages, err := h.querier.GetMessagesByThread(c, intVal)
// 	if err != nil {
// 		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
// 		return
// 	}

// 	if len(messages) == 0 {
// 		c.JSON(http.StatusNotFound, gin.H{"error": "No messages found for this thread"})
// 	}

// 	c.JSON(http.StatusOK, messages)
// }

func (h *MessageHandler) handleUpdateMessage(c *gin.Context) {
	var req repo.UpdateMessageParams
	if err := c.ShouldBindBodyWithJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := h.querier.Do().UpdateMessage(c, req); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"success": "Message updated successfully"})
}

func (h *MessageHandler) handleDeleteMessageById(c *gin.Context) {
	id := c.Param("id")
	if id == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "id is required"})
		return
	}

	// Execute the deletion inside the transaction
	_, err := h.querier.Do().DeleteMessageById(c, id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			c.JSON(http.StatusNotFound, gin.H{"error": "message not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "message deleted successfully"})
}

func (h *MessageHandler) handleDeleteMessageByThreadId(c *gin.Context) {
	id := c.Param("threadId")

	intId, err := helper.GetParamAsInt32(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, err.Error())
		return
	}

	_, err = h.querier.Do().DeleteMessageByThreadId(c, intId)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Message not found"})
			return
		}
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Message deleted successfully"})

}

// func (h *MessageHandler) handleCreateOrder(c *gin.Context) {
// 	var req repo.CreateOrderParams

// 	if err := c.ShouldBindBodyWithJSON(&req); err != nil {
// 		c.JSON(http.StatusBadRequest, err.Error())
// 		return
// 	}

// 	order, err := h.querier.Do().CreateOrder(c, req)
// 	if err != nil {
// 		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create order"})
// 		return
// 	}
// 	token := os.Getenv("AUTH_TOKEN")
// 	reference, err := requestPayment(req.PhoneNumber, fmt.Sprintf("%d", req.Amount), "Order Payment", token)
// 	if err != nil {
// 		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to initiate payment"})
// 		return
// 	}

// 	c.JSON(http.StatusOK, gin.H{
// 		"order":     order,
// 		"reference": reference,
// 		"message":   "Order created and payment request initiated.",
// 	})
// }

// paginated thread messages
func (h *MessageHandler) handleGetPaginatedThreadMessages(c *gin.Context) {
	id := c.Param("threadId")

	threadId, err := helper.GetParamAsInt32(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, err.Error())
		return
	}

	//parse pagination query params
	limit, err := strconv.Atoi(c.DefaultQuery("limit", "10"))
	if err != nil || limit <= 0 {
		limit = 10
	}

	offset, err := strconv.Atoi(c.DefaultQuery("offset", "0"))
	if err != nil || offset < 0 {
		offset = 0
	}

	messages, err := h.querier.Do().GetMessageByThreadPaginated(c, repo.GetMessageByThreadPaginatedParams{
		ThreadID: threadId,
		Limit:    int32(limit),
		Offset:   int32(offset),
	})

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to fetch messages"})
	}

	if len(messages) == 0 {
		c.JSON(http.StatusNotFound, gin.H{"message": "No messages found"})
		return
	}

	c.JSON(http.StatusOK, messages)
}
